<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Introduction · NexentaEdge</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Introduction · NexentaEdge"/><meta property="og:type" content="website"/><meta property="og:url" content="http://nexentaedge.io/index.html"/><meta property="og:description" content="Fast, feature rich and easy to use File, Block and Object storage for your Cloud-Native Applications. It is designed to make use of off the shelf storage and networking infrastructure and present it as enterprise grade SDS (Software-Defined Storage) solution."/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="http://nexentaedge.io/blog/atom.xml" title="NexentaEdge Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="http://nexentaedge.io/blog/feed.xml" title="NexentaEdge Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script><script type="text/javascript" src="https://unpkg.com/mermaid@8.0.0-rc.6/dist/mermaid.min.js"></script><script type="text/javascript" src="/js/main.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo-nexenta-full.png"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/introduction.html" target="_self">Documentation</a></li><li><a href="/blog" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Getting Started</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Getting Started</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/introduction.html">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/network-considerations.html">Networking Considerations</a></li><li class="navListItem"><a class="navItem" href="/docs/multi-tenancy-considerations.html">Multi-Tenancy Considerations</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/docs/webui-installation.html">Web UI Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/baremetal-installation.html">Bare Metal Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/docker-installation.html">Docker Integration</a></li><li class="navListItem"><a class="navItem" href="/docs/kubernetes-quick-start-solo.html">Kubernetes Quck Start &quot;Solo&quot;</a></li><li class="navListItem"><a class="navItem" href="/docs/kubernetes-installation.html">Kubernetes Integration</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/nexentaedge/nexentaedge.github.io/edit/master/src/docs/introduction.md" target="_blank">Edit</a><h1>Introduction</h1></header><article><div><span><p>Fast, feature rich and easy to use File, Block and Object storage for your Cloud-Native Applications. It is designed to make use of off the shelf storage and networking infrastructure and present it as enterprise grade SDS (Software-Defined Storage) solution.</p>
<p>NexentaEdge nodes are deployed as containers on physical or virtual hosts, pooling all their storage capacity and presenting it as fully compatible S3/SWIFT object access for containerized applications running on the same or dedicated servers. Additionally data can be accessed as native block devices (NBD), iSCSI (with optional HA), NFS shares (with optional HA) and as High-Performance NOSQL interface. Storage services are managed through standard Docker tools, for greater agility and scalability. Advanced CLI and nice GUI provided for easy of use.</p>
<p>NexentaEdge supported protocols:</p>
<ul>
<li>AWS compatible S3 object protocol</li>
<li>EdgeX-S3 - NexentaEdge specific extensions (RW objects, Snapshots/Clones, NOSQL K/V Database, and more)</li>
<li>OpenStack SWIFT object protocol</li>
<li>iSCSI with Active/Passive HA</li>
<li>NFSv3 with Active/Passive HA and horizontal scalability</li>
<li>NBD - Native Block Device (no iSCSI overhead, connected directly to Replicast backend network)</li>
</ul>
<p><img src="/docs/assets/high_level_diagram.png" alt="alt-text"></p>
<h3><a class="anchor" aria-hidden="true" name="ccow-technology-overview"></a><a href="#ccow-technology-overview" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CCOW: Technology overview</h3>
<p>Architecturally it is software defined clustered object storage solution built upon Cloud Copy on Write (CCOW) idea. Fundamentally it enforces full immutability of any data in the clustered global name space. That is metadata and data are equally made immutable and cannot be modified. Visually it can be presented as classic immutable binary trees data structure managing references to &quot;chunks&quot;. In CCOW objects split down into one or more chunks. Those chunks are immutable (“copy-on- write”), and their locations are not stored in the metadata. CCOW supports two types of object payload: an array of bytes and arrays of key/value records. File systems have long distinguished between data and metadata. CCOW stores metadata in Manifest Chunks, and data in Payload Chunks. Both are chunks, with nearly identical operations and characteristics.</p>
<p>With CCOW data format technology provides differentiating capabilities:</p>
<ul>
<li><p>guarantee of total and complete immutability of both Data and Metadata. Users data never gets overwritten and this creates number of advantages among which best in class data consistency and reliability</p></li>
<li><p>transparent bi-directional (upcoming feature) synchronization between multiple data-centers and clouds (Object interfaces only)</p></li>
<li><p>unique on-demand fetching technique and metadata only synchronization where only needed portions of object has to be fetched from the remote site (upcoming feature)</p></li>
<li><p>global metadata indexing and search with Elastic framework</p></li>
<li><p>embedded audit trails and rule based policy engine</p></li>
<li><p>end-to-end data integrity, resilience to networking splits and partial cluster availabilities. Data can be transported over long distances without loosing its original consistency</p></li>
<li><p>data (object, files and block volumes) and metadata stored as variable sized chunks, from 8KB to multi MB size chunks depending on I/O pattern requirements for the data access</p></li>
<li><p>cryptographic hash on all chunks stored in the cluster and no need for periodic scrubbing. Data is always consistent</p></li>
<li><p>immutable chunks simplify efficient multi-level caching throughout the scale-out cluster. Performance acceleration without the need for complex cache invalidation logic</p></li>
<li><p>local access point acceleration (network transfers avoidance). Application gateways can access locally provisioned storage, which can still be part of much larger global cluster name space</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" name="flexhash-and-replicast-technology-overview"></a><a href="#flexhash-and-replicast-technology-overview" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FlexHash and Replicast: Technology overview</h3>
<p>NexentaEdge is scale-out distributed clustered system of connected servers (nodes). Logically nodes can have designated data storage role, designated gateway role or combination of both roles (mixed). Nodes connected together via Ethernet fabric using low latency and high-performance UDP-based protocol called Replicast. While distribution of chunks is managed via directing hashing table called FlexHash. FlexHash dynamically organizing and assigns all disks into appropriate so-called &quot;Negotiating Group&quot;. Negotiating Group is group of disks distributed across physical servers and racks in accordance with selected policy (server or zone). FlexHash technology solves data placement challenges of consistent hashing. It dynamically places data based on utilization and rebalances resources automatically. Utilizing a dynamic, decentralized hash table allows NexentaEdge to scale to virtually unlimited size.</p>
<p><img src="/docs/assets/flexhash_diagram.png" alt="alt-text"></p>
<p>In the diagram above, the name of the Object is used to generate a digest using SHA-256. This digest is the starting point for named objects. For individual data chunks a content digest is used. The digest is used to look up a negotiation group of storage devices. Real time negotiation with members of Negotiation group using Replicast identifies the best number of replica target devices to use to store the object chunk based on utilization, latency or both policy.</p>
<p>FlexHash and Replicast provide failure resilient, high-performance and dynamic data placement with inline data-deduplication, high accuracy I/O load balancing, high-performance UDP-based transfers. Differentiating benefits can be summarized as:</p>
<ul>
<li><p>content addressable placement of data within a Negotiating Group. Not a consistent hash ring, improved operational efficiencies of rebalance/join/leave</p></li>
<li><p>dynamic negotiation of the “best device” to store data within that group. “Best” is a function of available device capacity, response time and queue depth, achieve close to 100% device utilization</p></li>
<li><p>no need to transfer data chunk if hash already exists in a Negotiating Group. A.K.A. Deduplication technique</p></li>
<li><p>transparent handling of hardware failures = Data flows around failures. A server failure simply reduces the number of candidate devices in a Negotiating Group. No need to ever “fail-back” data to a pre-determined location. It only needs to be in the right Negotiating Group. Great for seamless handling of network hiccups, or server reboots, or server maintenance operations</p></li>
<li><p>microsecond-level resolution data transfer protocol, using Ethernet and L3/UDP. Cost savings in achieving same or similar transfer speeds then with specialized hardware (RDMA/IB)</p></li>
<li><p>standard feature set of reliable storage transport with minimal overhead. Packets handled in user space, zero copy whenever possible and low latency processing</p></li>
<li><p>reliable delivery with “optional” Multi-cast Rendezvous Transfer. Write I/O san be up to 300% faster to transfer 3 replicas on the same networking port</p></li>
</ul>
<p>Replicast transport protocol is responsible for low latency and high throughput communications and supports the following modes of operation:</p>
<ul>
<li><p>UDP/IP Unicast (Cloud option) or Multicast communications within Negotiating Group</p></li>
<li><p>UDP/IP Unicast or Multicast communications within Rendezvous Transfer Group (group selected targeted devices)</p></li>
<li><p>TCP/IP communications within Rendezvous Transfer Group (Cloud option)</p></li>
<li><p>Accelerated PF_RING Rendezvous Transfer (aka DPDK-like based) or low CPU overhead option (upcoming feature)</p></li>
</ul>
<p>By default NexentaEdge installs in two configurations as far as Replicast transport protocol is concerned:</p>
<ul>
<li><p>Data Center option: with UDP/IP for Multicast in Negotiating Groups and UDP/IP Unicast for Rendezvous Transfers</p></li>
<li><p>Cloud option: with UDP/IP or TCP/IP Unicast only transport</p></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="network-considerations.html">NexentaEdge Networking Considerations →</a></div></div></div></div><footer class="nav-footer" id="footer"><section style="font-size:16px;display:flex;flex-direction:column;align-items:center;padding-top:10px;"><img src="/img/logo-nexenta-edge.png" style="height:60px;margin-bottom:10px;"/><a href="https://nexenta.com/products/nexentaedge" style="padding-bottom:20px;">NexentaEdge Product Page</a></section><section class="copyright">Copyright © 2018 Nexenta Systems, Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '839b05a95d1375c54722a0161e78d578',
                indexName: 'nexentaedge',
                inputSelector: '#search_input_react'
              });
            </script></body></html>